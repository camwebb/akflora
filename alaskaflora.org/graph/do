#!/usr/bin/gawk -f

BEGIN{

  init()
  
  read_query()

  if ((F["method"] == "namesearch") && (F["q"]))
    namesearch()
  else if ((F["method"] == "occ") && (F["id"]))
    map()
  else
    default_page()
}

# ---------- Methods functions ---------------------------------------------

function namesearch(     i, j, z, o, a, so, ag, sg, s, s2) {

  read_names()
  
  header("Name search")
  print "<h1>Name search</h1>"
  print "<p>Query = <i>" F["q"] "</i>;&#160;&#160;&#160; "  \
    "See layout <a href=\"#key\">key</a></p>"
  

  PROCINFO["sorted_in"] = "@val_str_asc"
  # consider each name
  for (i in Name)
    # if the name matches and is a canonical name
    if ((Name[i] ~ F["q"]) && Canon[i]) {
      o = a = so = ag = ""
      
      # consider the name that match the canon name
      if (isarray(Ortho_r[i]))
        for (j in Ortho_r[i]) {

          # cases other than self-matches...
          if (i != Ortho_r[i][j])
            # create an list of matches
            o = o "{" id2url(Ortho_r[i][j]) "}, "

          # is one of the matches a gbif name?
          if (Ortho_r[i][j] ~ /^gbif/)
            ag = 1

          # is the match an accepted name? Add source to list
          if (Accepted[Ortho_r[i][j]])
            a = a toupper(gensub(/-.*$/,"","G",Ortho_r[i][j])) ", "

          # Now look at synonyms
          if (Canon[Ortho[Syn[Ortho_r[i][j]]]]) {
            # create a list of non-canonical synonyms
            s[Ortho[Syn[Ortho_r[i][j]]]] =                          \
              s[Ortho[Syn[Ortho_r[i][j]]]] "|" Syn[Ortho_r[i][j]]
            
            # does the accepted name have a gbif match?
            if (Syn[Ortho_r[i][j]] ~ /^gbif/)
              sg[Ortho[Syn[Ortho_r[i][j]]]] = 1
          }
        }
        
      gsub(/, $/,"",o)
      gsub(/, $/,"",a)

      # process synonyms
      if(isarray(s))
        for (z in s) {
          # create first part of synonym output string
          so = so "<div style=\"padding-left:40px;text-indent:-20px;\">" \
            "<i>SYNONYM</i> of <b>" Name[z] "</b> {" id2url(z)          \
            "} according to "
          gsub(/^\|/,"",s[z])
          split(s[z], s2, "|")
          # add the sources that agree with this synonym
          for (x in s2)
            so = so toupper(gensub(/-.*$/,"","G", s2[x])) " ‚Üê {"    \
              id2url(s2[x]) "}, "
          gsub(/, $/,"",so)
          # and a map if there is a gbif match
          if (sg[z])
            so = so " <a href=\"do?method=occ&id=" z "\">üó∫</a>"
          so = so "</div>"
        }
      delete s
      delete sg

      # if there is either a match to something else, or the name is accepted
      if (o || a)
        print                                                           \
          "<p>"                                                         \
          "<div style=\"padding-left:20px;text-indent:-20px;\">"        \
          "<b>" Name[i] "</b> {" id2url(i) "}"                          \
          ((o) ? (" ‚Üê " o ) : "")                                       \
          ((ag) ? (" <a href=\"do?method=occ&id=" i "\">üó∫</a>") : "")   \
          "</div>"                                                      \
          ((a) ? ("<div style=\"padding-left:20px;\"><i>ACCEPTED</i> by " \
                  a "</div>") : "")                                     \
          so                                                            \
          "</p>"
    }

  print "<hr/>"
  print "<p><i>Key to layout of each entry:</i><br/>"
  print "<div style=\"padding-left:40px;text-indent:-40px;\">"          \
    "<b>Name (as matched to a canonical name)</b> { canonical identifier } " \
    "‚Üê { matching name identifier }, ... üó∫ (= link to occurences of "   \
    "this name and synonyms)</div>"
  print "<div style=\"padding-left:20px;\"><i>ACCEPTED</i> by " \
    "SOURCE1, SOURCE2... </div>" 
  print "<div style=\"padding-left:40px;text-indent:-20px;\"><i>SYNONYM</i>" \
    " of <b>Name</b> { canonical identifier } according to SOURCE1 "    \
    "{ identifier of matching accepted name }, ... üó∫ (= link to "       \
    "occurences of this name and synonyms)</div>" 
  
  footer()
}

function map(     i, j, k, l, tid, tname, ssyn, cano, srce               ) {

  read_names()

  for (i in Name)
    if (i == F["id"])
      if (isarray(Ortho_r[i]))
        for (j in Ortho_r[i]) {
          if (Ortho_r[i][j] ~ /^gbif/) {
            tid = Ortho_r[i][j]
            tname = Name[i]
          }
          # print i, j, Ortho_r[i][j], Name[Ortho_r[i][j]]
          if (isarray(Syn_r[Ortho_r[i][j]]))
            for (k in Syn_r[Ortho_r[i][j]]) {
              ssyn[i,j,k] = toupper(gensub(/-.*$/,"","G", Syn_r[Ortho_r[i][j]][k]))
              # print i, j, k, Syn_r[Ortho_r[i][j]][k], Name[Syn_r[Ortho_r[i][j]][k]]
                
              if (isarray(Ortho_r[Ortho[Syn_r[Ortho_r[i][j]][k]]]))
                for (l in Ortho_r[Ortho[Syn_r[Ortho_r[i][j]][k]]]) {
                  # print i, j, k, l, Ortho_r[Ortho[Syn_r[Ortho_r[i][j]][k]]][l], Name[Ortho_r[Ortho[Syn_r[Ortho_r[i][j]][k]]][l]]
                  if (Ortho_r[Ortho[Syn_r[Ortho_r[i][j]][k]]][l] ~ /^gbif/) {
                    cano[Ortho_r[Ortho[Syn_r[Ortho_r[i][j]][k]]][l]] =  \
                      Ortho[Syn_r[Ortho_r[i][j]][k]]
                    srce[Ortho_r[Ortho[Syn_r[Ortho_r[i][j]][k]]][l]] =  \
                      srce[Ortho_r[Ortho[Syn_r[Ortho_r[i][j]][k]]][l]]  \
                      ssyn[i,j,k] ", "
                  }
                }
            }
        }

  for (i in srce)
    gsub(/, $/,"",srce[i])
    
  header("Map")
  print "<h1>Map of " tname "</h1>"
  print "<p>" tname " {" F["id"] "} ‚Üê {" tid "}</p>"
  print "<pre>"

  for (i in cano)
    print Name[cano[i]] " {" cano[i] "} ‚Üê {" i "}, a synonym according to " \
      srce[i]
  cano[tid] = F["id"]
    
  FS = "|"
  OFS = " : "
  while ((getline < "occ") > 0)
    if (cano[$4])
      print $1, $2, $3, $5, cano[$4]
  # test with salix bebbiana Sarg.

  print "</pre>"
  footer()
}

# ---------- I/O functions -------------------------------------------------

function read_query(   qs, q, qp) {

  split(ENVIRON["QUERY_STRING"], qs, "&")
  for (q in qs) {
    split(qs[q], qp, "=")
    F[qp[1]] = substr(urldecode(qp[2]),1,100)
  }
}

function read_names() {

  FS = "|"
  while ((getline < "names") > 0) {
    Name[$1] = $3
    Canon[$1] = $4
    Ortho[$1] = $5
    Ortho_r[$5][++n_Ortho_r[$5]] = $1
    Accepted[$1]  = $6
    Syn[$1]  = $7
    Syn_r[$7][++n_Syn_r[$7]] = $1
    Inak[$1] = $8
  }
}

# ---------- HTML functions ------------------------------------------------

function header(title) {
  # version history: [chars app] -> [tcm app] -> [hulten] -> [qm] -> here
  
  print "Content-type: text/html\n\n"                                   \
    "<!DOCTYPE html>"                                                   \
    "<html xmlns=\"http://www.w3.org/1999/xhtml\" "                     \
    "      prefix=\"og: https://ogp.me/ns#\">"                          \
    "<head><title>" title "</title>"                                    \
    "<meta http-equiv=\"Content-Type\" content=\"text/html;"            \
    "charset=utf-8\" />"                                                \
    "<link rel=\"icon\" type=\"image/png\" href=\"../img/favicon.png\"/>"
  print "<style type=\"text/css\">"                                     \
    "body { font-size: 14px; font-family: 'Montserrat', "               \
    "Verdana, Arial, Helvetica, sans-serif; }"                          \
    ".main {width: 1000px; padding-top: 10px; margin-left: auto;"       \
    "  margin-right: auto; }"                                           \
    "h1 { padding-top:20px; }"                                          \
    "select , option { font-size: 14px }"                               \
    "table { border-collapse: collapse }"                               \
    "td, th { border: 1px solid black; padding: 5px }"                  \
    "a { color:#15358d; text-decoration:none; border-bottom-style:none }" \
    "a:visited { color:#9f1dbc }"                                       \
    "a:hover {color:#15358d; border-bottom-style:solid; "               \
    "border-bottom-width:thin }"                                        \
    "</style>"                                                        
  
  # print "<link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.7.1/dist/leaflet.css\" integrity=\"sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==\" crossorigin=\"\"/>"
  # print "<script src=\"https://unpkg.com/leaflet@1.7.1/dist/leaflet.js\" integrity=\"sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==\" crossorigin=\"\"></script>"

  print "</head>\n<body>"
  print "<div class=\"main\">"

}

function footer() {
   
  print "</div>"
  print "</body>\n</html>";
}

function id2url(id  , i) {
  for (i in Url)
    # special rule for hulten, temporary
    if ((id ~ ("^" i)) && (id !~ /^hulten[0-9-]+[sb]/))
      id = "<a target=\"_blank\" href=\"" gensub(("^" i "-"), Url[i], "G", id) "\">" \
        id "</a>"
  return id
}

# ---------- Helper functions ----------------------------------------------

function urldecode(text,   hex, i, hextab, decoded, len, c, c1, c2, code) {
# decode urlencoded string
# urldecode function from Heiner Steven
#   http://www.shelldorado.com/scripts/cmds/urldecode
# version 1
	
  split("0 1 2 3 4 5 6 7 8 9 a b c d e F", hex, " ")
  for (i=0; i<16; i++) hextab[hex[i+1]] = i
  
  decoded = ""
  i = 1
  len = length(text)
  
  while ( i <= len ) {
    c = substr (text, i, 1)
    if ( c == "%" ) {
      if ( i+2 <= len ) {
        c1 = tolower(substr(text, i+1, 1))
        c2 = tolower(substr(text, i+2, 1))
        if ( hextab [c1] != "" || hextab [c2] != "" ) {
          # print "Read: %" c1 c2;
          # Allow: 
          # 20 begins main chars, but dissallow 7F (wrong in orig code!)
          #   tab, newline, formfeed, carriage return
          if ( ( (c1 >= 2) && ((c1 c2) != "7f") )   \
               || (c1 == 0 && c2 ~ "[9acd]") )
            {
              code = 0 + hextab [c1] * 16 + hextab [c2] + 0
              # print "Code: " code
              c = sprintf ("%c", code)
            } else {
            # for dissallowed chars
            c = " "
          }
          i = i + 2
        }
      }
    } else if ( c == "+" ) 	# special handling: "+" means " "
      c = " "
    decoded = decoded c
    ++i
  }
  
  # change linebreaks to \n
  gsub(/\r\n/, "\n", decoded);
  # remove last linebreak
  gsub(/[\n\r]*$/,"",decoded);
  return decoded
}

function init(   i, url1, url2, url3) {
  url1 = \
    "ipni^https://www.ipni.org/n/|"                                     \
    "gbif^https://www.gbif.org/species/|"                               \
    "trop^http://legacy.tropicos.org/Name/|"                            \
    "kew^http://www.theplantlist.org/tpl1.1/record/kew-|"               \
    "paf^http://panarcticflora.org/#paf-|"                              \
    "hulten^https://alaskaflora.org/hulten/do?method=detail\\&id="    
  split(url1, url2, "|")
  for (i in url2) {
    split(url2[i], url3,"^")
    Url[url3[1]] = url3[2]
  }
}
